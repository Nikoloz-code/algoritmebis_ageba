# როგორ გრაფს ეწოდება ხე, განმარტეთ მინიმალური დამფარავი ხე. მოიყვანეთ მინიმალური დამფარავი ხის ძებნის კრასკალის ალგორითმი და შეაფასეთ საჭირო ოპერაციების რაოდენობა
## როგორ გრაფს ეწოდება ხე?
---
ხე ეწოდება **ბმულ აციკლურ არაორიენტირებულ გრაფს**. მას ასევე ეწოდება **თავისუფალი ხე**. ხოლო *აციკლურ არაონტირებულ გრაფს* **ტყე**.
## განმარტეთ მინიმალური დამფარავი ხე
---
**დამფარავი ხე** არის *აციკლური სიმრავლე* რომელიც აერთებს რაიმე G გრაფის ყველა წვეროს.

ვთქვათ გვაქ მოცემული ბმული არაოონტირებული G გრაფი: $G = (V, E)$
*(V არის გრაფში მოცემული წვეროები, ხოლო E არის გრაფში მოცემული წიბოები)*

გრაფის ყოველი $(u, v) \in E$ წიბოსათვის მოცემულია $w(u,v)$ არაუარყოფითი წონა. უნდა ვიპოვოთ ისეთი ბმული, აციკლური ქვესიმარვლე $T \subseteq E$, რომელიც მოიცავს ყველა წვეროს და რომლისთვისაც ყოველი წვეროს ჯამური წონა არის მინიმალური.  *(მათემატიკური გამოსახვა)* $$w(T)=\sum_{(u,v)\in T}w(u,v)$$ანუ, *აციკლური სიმრავლე*, რომელიც აერთებს G გრაფის ყველა წვეროს, რომლის *წვეროების ჯამური წონაა მინიმალური*, წარმოადგენს **მინიმალურ დამფარავ ხეს**. 
## მოიყვანეთ დამფარავი ხის ძებნის **კრასკალის ალგორითმი** და შეაფასეთ საჭირო ოპერაციების რაოდენობა
---
>[!CAUTION]
>არვიცი რა იგულისხმება ალგორითმის მოყვანით, ზოგადი განმარტება თუ ბიჯები, ამიტომაც თქვენ თქვითონ აირჩიეთ აქედან რაც დაწერთ.
### ზოგადი მიმოხილვა

**კრასკალის ალგორითმი** არის ხარბი ალგორითმი *(Greedy Algorithm)*. კრასკალის ალგორითმში **A სიმრავლე** წარმოადგენს *ტყეს*. **A-ს** ემატება *უსაფრთხო წიბოები*, რომელიც არის **ორი სხვადასხვა კომპონენტის დამაკავშირებელი მინიმალური წონის მქონე წიბოები**.

> [!IMPORTANT] 
> ალგორითმის მუშაობისთვის საჭიროა ბმული არაონტირებული G გრაფი და წიბოთა w წონები.
- ალგორითმი ყველა წიბოს ზრდის მიხედვით ალაგებს.
- ალგორითმი ტყეში დასამატებლად ეძებს უსაფრთხო მინიმალური წონის მქონე წიბოს ყველა იმ წიბოს შორის, რომელიც აკავშირებს სხვადასხვა ხეს ტყეში.
- უსაფრთხო წიბოში იგულისხმება ისეთი წიბო, რომელიც არ ქმნის ციკლს.
---
### ბიჯები

სანამ დავიწყებთ კრასკალის ალგორითმს, აუცილებელია რომ
- A სიმრავლე იყოს ცარიელი.
- შევქმნათ სიმრავლე ყოველი წვეროსთვის.
- დავალაგოთ წიბოები ზრდის მიხედვით.

ალგორითმი შემდეგნაირად მუშაობს:

1. ალგორითმი იწყებს `for` ციკლს ყოველი წიბოსთვის.
2. თუ `(u,v)` წიბოში, `u` და `v` წვეროები არ იძებნება ამ ორი წვეროს ერთ-ერთი სიმრავლეში, დავამატოთ იგი **A** სიმრავლეში და გავაერთიანოთ ეს ორი სიმრავლე. ანუ:
   $if\space FIND-SET(u) \not= FIND-SET(v):$ 
	   $A=A \cup \{(u,v)\};$
	   $UNION(u,v)$
3. თუ ორი წვეროს ერთ-ერთი სიმრავლეში ერთნაირი წვერო მოიძებნა, ალგორითმი მას არ დაამატებს **A** სიმრავლეში.
4. ციკლის დამთავრების შემდეგ, ალგორითმი დააბრუნებს **A** სიმრავლეს.

კრასკალის ალგორითმის მუშაობის საერთო დრო არის $O(E\space logE)$.
____
### ფსევდოკოდი

>[!CAUTION]
>ეს ნაწილი არ არის აუცილებელი ამ კითხვისთვის, არის მარტო ინტერესისთვის.

```python
MST-KRUSKAL(G, w):
	A = Ø
	for ∀v ∈ G.V:
		MAKE-SET(v)
	sort(G.E)
	for ∀(u,v) ∈ G.E:
		if FIND-SET(u) != FIND-SET(v):
			A = A ∪ {(u,v)}
			UNION(u,v)
	return A
```