ვთქვათ, მოცემულია n განაცხადი ერთსა და იმავე აუდიტორიაში მეცადენიეობის ჩატარებაზე.
ორი განსხვავებული მეცადინეობა არ შეიძლება დროში გადაიფაროს.
ყოველ განაცხადში მითითებულია მეცადინეობის დაწყებისა და დამთავრების დრო (i-ური განაცხადისათვის შესაბამისად s<sub>i</sub> და f<sub>i</sub>).
სხვადასხვა განაცხადები შეიძლება გადაიკეთონ, მაგრამ ამ შემთხვევაში დაკმაყოფილდება მხოლოდ ერთი მათგანი. ჩვენ ვაიგიეებთ თითოეულ განაცცადს [s<sub>i</sub>,f<sub>i</sub>) შუალედთან, ასე რომ ერთ მიეცადინეობის დამთავრების დრო შეიძლება დაემთხვეს მეორის დაწყებას და ასეთი სიტუაცია გადაკვეთად არ ითვლება.

ზოგადად i და j ნომრების მქონე განაცხადები თავსებადია (compatible) თუკი [s<sub>i</sub>,f<sub>i</sub>) და [s<sub>j</sub>,f<sub>j</sub>) ინტერვალები არ თანაიკვეთებიან (სხვა სიტყვებით, თუ f<sub>i</sub> <= s<sub>j</sub> ან f<sub>j</sub> <= s<sub>i</sub>).

## ამოცანა განაცხადების შერჩევაზე (activity-selection-problem)
მდგომარეობს იმაში, რომ ამოვარჩიოთ ერთმანეთთან თავსებადი მაქსიმალური რაოდენობის განაცხადი.
ამ ამოცანაში, ხარბი ალგორითმი მუშაობს შემდეგნაირად:
- დავუშვათ განაცხადები დალაგებულია დამთავრების დროის ზრდადობის მიხედვით:
- f<sub>1</sub> <= f<sub>2</sub> <= ... <= f<sub>n</sub>
- თუ მონაცემები არ არის დალლაგებული, მისი დალაგება შესაძლებელია O(nlog(n)) დროში. თუ განაცხადებს ერთნაირი დამთავრების დრო აქვთ, ისინი შეიძლება განლაგდნენ ნებისმიერად.

თუ f-ს და s-ს განვიხილავთ როგორც შესაბამის მასივებს, ალგორითმს ექნება სახე:

# ფსევდოკოდი

```
GREEDY-ACTIVITY-SELECTOR(s, f) :
  n = len(s);
  A = {1};
  j = 1;
  for i=2; i<=n; i++ :
    if s[i] >= f[j] :
      A = A ∪ {i};
      j = i;
  return A;
```

ალგორითი მუშაობს n-ის პროპორციულ დროში.

![image](https://github.com/user-attachments/assets/3231c567-5da2-45eb-be88-567d3009b4f8)
![image](https://github.com/user-attachments/assets/7e5d7f42-2d66-49fa-a1c2-381131999ee5)

