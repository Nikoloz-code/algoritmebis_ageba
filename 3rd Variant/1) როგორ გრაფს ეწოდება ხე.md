# როგორ გრაფს ეწოდება ხე, განმარტეთ მინიმალური დამფარავი ხე. მოიყვანეთ მინიმალური დამფარავი ხის ძებნის პრიმის ალგორითმი და შეაფასეთ საჭირო ოპერაციების რაოდენობა
## როგორ გრაფს ეწოდება ხე?
---
ხე ეწოდება **ბმულ აციკლურ არაორიენტირებულ გრაფს**. მას ასევე ეწოდება **თავისუფალი ხე**. ხოლო *აციკლურ არაონტირებულ გრაფს* **ტყე**.
## განმარტეთ მინიმალური დამფარავი ხე
---
**დამფარავი ხე** არის *აციკლური სიმრავლე* რომელიც აერთებს რაიმე G გრაფის ყველა წვეროს.

ვთქვათ გვაქ მოცემული ბმული არაოონტირებული G გრაფი: $G = (V, E)$
*(V არის გრაფში მოცემული წვეროები, ხოლო E არის გრაფში მოცემული წიბოები)*

გრაფის ყოველი $(u, v) \in E$ წიბოსათვის მოცემულია $w(u,v)$ არაუარყოფითი წონა. უნდა ვიპოვოთ ისეთი ბმული, აციკლური ქვესიმარვლე $T \subseteq E$, რომელიც მოიცავს ყველა წვეროს და რომლისთვისაც ყოველი წვეროს ჯამური წონა არის მინიმალური.  *(მათემატიკური გამოსახვა)* $$w(T)=\sum_{(u,v)\in T}w(u,v)$$ანუ, *აციკლური სიმრავლე*, რომელიც აერთებს G გრაფის ყველა წვეროს, რომლის *წვეროების ჯამური წონაა მინიმალური*, წარმოადგენს **მინიმალურ დამფარავ ხეს**. 
## მოიყვანეთ დამფარავი ხის ძებნის **პრიმის ალგორითმი** და შეაფასეთ საჭირო ოპერაციების რაოდენობა
---
>[!CAUTION]
>არვიცი რა იგულისხმება ალგორითმის მოყვანით, ზოგადი განმარტება თუ ბიჯები, ამიტომაც თქვენ თქვითონ აირჩიეთ აქედან რაც დაწერთ.

### ზოგადი მიმოხილვა

**პრიმის ალგორითმი** არის ხარბი ალგორითმი *(Greedy Algorithm)*. ალგორითმში A სიმრავლე წარმოადგენს *ერთიან ხეს*. ყოველ ბიჯზე, A-ს ემატება წიბოები, რომელთაც აქვთ მინიმალური წონა და რომლებიც აერთიანებენ ფესვის მქონე ხეს მის არაწევრ წვეროებთან.

> [!IMPORTANT] 
> ალგორითმის მუშაობისთვის საჭიროა ბმული G გრაფი, წიბოთა w წონები, s საწყისი წვერო და Q პრიორიტეტის რიგი.

 - ალგორითმის მუშაობისას ყველა წვერო, რომელიც ჯერ არ გამხდარა A სიმრავლის წევრი, ინახება ***Q** პრიორიტეტებიან რიგში*.
 - v წვეროს *პრიორიტეტი* განისაზღვრება $key[v]$ მნიშვნელობით. იგი უდრის იმ წიბოების მინიმალურ წონას, რომელიც აერთებს v წვეროს A ხესთან. თუ ასეთი წიბო არ არსებობს, მაშინ $key[v]$ = ∞.
 - $\pi[v]$ ინახავს ხის წვეროს, რომლისკენაც მივყავართ $key[v]$ წონის წიბოს.
---
### ბიჯები

სანამ დავიწყებთ პრიმის ალგორითმს, აუცილებელია რომ 

- ყველა წვეროს წონა გახდეს უსასრულო, ანუ $key[u] = ∞$, ხოლო ყოველი წვეროს მშობელი კი გავხადოთ ნული, ანუ $\pi[u] = NIL$. 
- საწყისი s წვეროს წონა იყოს 0.
- პრიორიტეტების რიგში იყოს გრაფის ყოველი წვერო, ანუ $Q = V$.

ალგორითმი შემდეგნაირად მუშაობს:

1) ალგორითმი იწყებს $while$ ციკლს რომელიც არ დამთავრდება სანამ პრიორიტეტების რიგი არაა ცარიელი.
2) ალგორითმი ირჩევს ნებისმიერ წვეროს $Q$ პრიორიტეტების რიგიდან რომელსაც გააჩნია მინიმალური წონა ($key$) და შლის მას $Q$ პრიორიტეტების რიგიდან $EXTRACT-MIN$ ფუნქციის საშუალებით. ესეთ წვეროს ვუწოდოთ $u$ წვერო.
   *(ალგორითმის დაწყებაში,* $s$ *საწყისს წვეროს გააჩნია მინიმალური წონა, რის გამო ჯერ საწყისი წვეროს მეზობლებს განიხილავს, შემდგომში კი შემოწმებული წვეროების ყველა მეზობლებს.)*
3) თუ $u$ წვეროს ნებისმიერი $v$ მეზობელი ეკუთვნის პრიორიტეტების რიგს *(ანუ არ არის შემოწმებული)* და $v$ წვეროს წონა არის ნაკლები წიბოს წონაზე, ანუ $$if\space (v \in Q\space and\space w(u,v)<key[v])$$, მაშინ მეზობელი წვეროს მშობელი გავხადოთ $u$, ანუ $\pi[v]=u$ ხოლო წონა, ანუ $key[v]$ კი წიბოს წონა, $w(u,v)$.
4) ციკლი როდესაც დამთავრდება, ანუ როდესაც პრიორიტეტის რიგი ცარიელია *(ყველა წვერო განვიხილეთ)*, დავაბრუნებთ მინიმალური დამფარავი ხის მინიმალური წიბოების წონების ჯამს.

პრიმის ალგორითმის მუშაობის საერთო დრო არის $O(E\space logV)$.
____
### ფსევდოკოდი

>[!CAUTION]
>ეს ნაწილი არ არის აუცილებელი ამ კითხვისთვის, არის მარტო ინტერესისთვის.

ფსევდოკოდი:
```python
MST-PRIM(G,w,r):
	for ∀u ∈ G.V:
		key[u] = infinity
		π[u] = NIL
	key[r] = 0
	Q = G.V # Q is all the vertices in a graph
	while Q != NULL:
		u = EXTRACT-MIN(Q) # add u to the tree
		for ∀v ∈ G.adj[u]: # update keys of u's neighbours
			if v ∈ Q and w(u,v) < v.key:
				π[v] = u
				key[v] = w(u,v)
	return π # tree is made of (v,π[v]) edges
```
